# Project: [Your Project Name]

## Agentic Workflow Standards

### 1. TDD Core
Strictly follow Test-Driven Development for all functional changes.
- Write the failing test FIRST, run it to confirm failure.
- Write the minimum implementation to make it pass.
- Refactor only after green.
- Never mark a task as "Done" until tests show 100% pass rate.

### 2. Mirror Testing Rule
Every source file must have a corresponding test file:

- **Backend tests:** Verify core logic accuracy and edge cases.
- **Frontend tests:** Verify UI components return the exact data structures required by the logic layer.

### 3. Execution Protocol
- Before implementation: write test → run test → see RED.
- After implementation: run test → see GREEN (100% pass).
- On commit: all tests must pass.

### 4. UI Standard
<!-- Define your design system reference, e.g.:
All frontend code must follow the design system defined in `docs/specs/design_system.md`:
- Design tokens in CSS (no magic numbers).
- Only the bridge layer imports from logic/data. Components are pure renderers.
-->

### 5. Spec-to-Code Mapping

Each spec in `docs/specs/` maps 1:1 to source modules. Maintain this mapping table in CLAUDE.md or `req/GLOBAL_MASTER.md`:

**Example mapping table**:
```markdown
| Spec File | Source Modules | Purpose |
|-----------|----------------|---------|
| `docs/specs/data_layer.md` | `src/models.py`, `src/database.py` | Data models and persistence |
| `docs/specs/business_logic.md` | `src/services.py` | Core business rules |
| `docs/specs/api.md` | `src/routes.py`, `src/controllers.py` | REST API endpoints |
```

**Spec content template**:
- **Responsibilities**: What this module does
- **Public Interface**: Key functions/classes with signatures
- **Integration Points**: How it connects to other modules
- **Testing**: Test file location and coverage requirements
- **Design Principles**: Key architectural decisions

**When to create specs**:
- ✅ During design phase (before implementation)
- ✅ After implementation (if designed in plans)
- ❌ Never as afterthought documentation

**When to update specs**:
- Immediately when public interface changes
- When integration points change
- When design principles evolve

## Document Hierarchy

Three-layer documentation. Claude reads **this file** automatically; read others **on demand** as described below.

```
CLAUDE.md                  ← Always loaded (base rules related to project)
req/                       ← Requirements (WHAT)
  GLOBAL_MASTER.md           ← Constitution: universal constraints for ALL features
  PHASE_N_*.md               ← Individual feature requirements
docs/specs/                ← Design specs (HOW), 1:1 mapped to source modules
docs/plans/                ← Temporary working docs (not maintained post-implementation)
```

### Reading Protocol
- **Before any implementation task:** read `req/GLOBAL_MASTER.md` first — it contains architectural constraints, phased roadmap, and business rules that apply to all code.
- **When modifying existing code:** read the corresponding `docs/specs/*.md` (see Spec-to-Code Mapping above) to understand the current design contract.
- **When implementing a new feature/phase:** read `req/GLOBAL_MASTER.md` + the relevant `req/PHASE_N_*.md` to understand requirements, then read/create the corresponding spec.
- **Do NOT load all docs at once.** Only read files relevant to the current task.

### Adding New Requirements

**For universal constraints** (apply to all features):
```bash
# Append to constitution
echo "## New Architecture Rule" >> req/GLOBAL_MASTER.md
git commit -m "docs: add [constraint name] to architecture rules"
```

**For new features/phases**:
1. Create requirement document:
   ```bash
   # Use descriptive phase naming
   touch req/PHASE_N_FEATURE_NAME.md
   ```

2. During design:
   - Create `docs/plans/YYYY-MM-DD-<feature>-design.md`
   - Explore, iterate, refine

3. During implementation:
   - Create `docs/plans/YYYY-MM-DD-<feature>-implementation.md`
   - Follow TDD protocol
   - Create/update `docs/specs/*.md` as you build

4. After completion:
   - Delete `docs/plans/*.md` for this feature
   - Archive `req/PHASE_N_FEATURE_NAME.md`
   - Update Spec-to-Code Mapping in CLAUDE.md
   - Update Mirror Testing Rule if new test files added

**Naming conventions**:
- Requirements: `req/PHASE_1_USER_AUTH.md`, `req/PHASE_2_PAYMENTS.md`
- Use semantic phase names (not just numbers)
- Capitalize for easy scanning

### Plans Workflow

**Purpose**: Plans are temporary working documents that guide implementation. They are **throwaway** — specs are the permanent record.

**Naming convention**: `docs/plans/YYYY-MM-DD-<feature-name>-<type>.md`
- `<type>` = `design` | `implementation` | `analysis`

**Example**:
```
docs/plans/2026-01-15-user-auth-design.md
docs/plans/2026-01-15-user-auth-implementation.md
```

**Lifecycle**:
1. **Create**: During brainstorming/planning phase
2. **Use**: Guide implementation step-by-step
3. **Delete**: Immediately after specs are synced with code

**Cleanup process**:
```bash
# After feature complete and specs synced
git rm docs/plans/2026-01-15-user-auth-*.md
git commit -m "docs: cleanup user-auth plans (specs synced)"
```

**Critical rules**:
- ❌ Never reference plans in code comments
- ❌ Never read plans to understand existing code
- ✅ Always use specs for understanding current implementation
- ✅ Delete all plans for a feature in a single commit

### Document Lifecycle

**Goal**: `req/` should converge to **only `GLOBAL_MASTER.md`** as features are implemented.

#### Lifecycle Rules

| Document Type | Path | Lifespan | Action When Feature Complete |
|---------------|------|----------|------------------------------|
| **Constitution** | `req/GLOBAL_MASTER.md` | Permanent | Never archive |
| **Requirements** | `req/PHASE_N_*.md` | Until implemented | Archive to `archive/` via `git mv` |
| **Specifications** | `docs/specs/*.md` | While code exists | Keep 1:1 with source modules |
| **Plans** | `docs/plans/*.md` | During implementation | Delete after specs synced |

#### Implementation Completion Checklist

When a feature/phase is fully implemented:

1. ✅ **All tests pass** (100%)
2. ✅ **Create/update `docs/specs/*.md`** for all modified modules
3. ✅ **Delete `docs/plans/*.md`** files for this feature
4. ✅ **Archive `req/PHASE_N_*.md`** to `archive/` via `git mv`
5. ✅ **Update Spec-to-Code Mapping** in CLAUDE.md (if new modules added)

**Critical**: Never delete plans before creating specs. Specs are the permanent record.

#### Directory States

**Active Development**:
```
req/
  ├── GLOBAL_MASTER.md
  └── PHASE_2_feature.md        ← Active work

docs/specs/
  ├── module_a.md
  └── module_b.md

docs/plans/
  └── 2026-01-15-phase-2-implementation.md  ← Temporary
```

**After Phase 2 Complete**:
```
req/
  └── GLOBAL_MASTER.md          ← Only constitution remains

archive/
  └── PHASE_2_feature.md        ← Archived requirement

docs/specs/
  ├── module_a.md
  ├── module_b.md
  └── module_c.md               ← New spec added

docs/plans/
  └── (empty)                   ← Plan deleted
```

#### Archive Directory

**When to create**: First time you archive a requirement.

**How to archive**:
```bash
mkdir -p archive
git mv req/PHASE_N_feature.md archive/
git commit -m "docs: archive Phase N requirements (fully implemented)"
```

**Reading archived docs**: Only when user explicitly asks. `req/` contains only active work.

### Source of Truth Hierarchy

1. **For current implementation**: `docs/specs/*.md` (1:1 with code)
2. **For original intent**: `req/PHASE_N_*.md` (may drift from implementation)
3. **For universal constraints**: `req/GLOBAL_MASTER.md` (architectural rules)

**Note**: Specs reflect what was actually built; requirements reflect what was planned.

### Conflict Resolution
- `req/GLOBAL_MASTER.md` Roadmap Index is a summary only. Detailed requirements live in `req/PHASE_N_*.md` — these take precedence.
- When specs and requirements conflict, specs are authoritative (they reflect actual code).

## Architecture Rules
<!-- Define your project-specific architecture rules here, e.g.:
- **Import direction:** Define your module dependency hierarchy
- **Data model:** Define your central data structures
- **Config authority:** Define where configuration lives
- **External APIs:** Define how external services are accessed
- **Error handling:** Define error isolation strategy
-->

---

## CLAUDE.md Template for New Projects

**Use this template when starting a new project.** Copy to `<project>/CLAUDE.md` and customize.

```markdown
# Project: [Your Project Name]

## Agentic Workflow Standards

### 1. TDD Core
Strictly follow Test-Driven Development for all functional changes.
- Write the failing test FIRST, run it to confirm failure.
- Write the minimum implementation to make it pass.
- Refactor only after green.
- Never mark a task as "Done" until tests show 100% pass rate.

### 2. Mirror Testing Rule
Every source file must have a corresponding test file:

<!-- Add your project-specific mappings here:
- `src/module_a.py` → `tests/test_module_a.py`
- `src/module_b.py` → `tests/test_module_b.py`
-->

### 3. Execution Protocol
- Before implementation: write test → run test → see RED.
- After implementation: run test → see GREEN (100% pass).
- On commit: all tests must pass.

## Spec-to-Code Mapping

**Maintain this table as you add modules:**

| Spec File | Source Modules | Purpose |
|-----------|----------------|---------|
| `docs/specs/[module].md` | `src/[files].py` | [Description] |

<!-- Example:
| `docs/specs/data_layer.md` | `src/models.py`, `src/database.py` | Data models and persistence |
| `docs/specs/business_logic.md` | `src/services.py` | Core business rules |
| `docs/specs/api.md` | `src/routes.py`, `src/controllers.py` | REST API endpoints |
-->

## Document Hierarchy

Three-layer documentation. Claude reads **this file** automatically; read others **on demand** as described below.

```
CLAUDE.md                  ← Always loaded (base rules related to project)
req/                       ← Requirements (WHAT)
  GLOBAL_MASTER.md           ← Constitution: universal constraints for ALL features
  PHASE_N_*.md               ← Individual feature requirements
docs/specs/                ← Design specs (HOW), 1:1 mapped to source modules
docs/plans/                ← Temporary working docs (not maintained post-implementation)
```

### Reading Protocol
- **Before any implementation task:** read `req/GLOBAL_MASTER.md` first — it contains architectural constraints, phased roadmap, and business rules that apply to all code.
- **When modifying existing code:** read the corresponding `docs/specs/*.md` (see Spec-to-Code Mapping above) to understand the current design contract.
- **When implementing a new feature/phase:** read `req/GLOBAL_MASTER.md` + the relevant `req/PHASE_N_*.md` to understand requirements, then read/create the corresponding spec.
- **Do NOT load all docs at once.** Only read files relevant to the current task.

## Architecture Rules

**Define your project-specific architecture here:**

<!-- Examples:
- **Import direction:** `main.py → services.py → models.py` (never reverse)
- **Data model:** [CentralDataClass] is the central data structure passed between modules
- **Config authority:** All configuration lives in `config.yaml`, loaded via `src/config.py`
- **External APIs:** All API calls go through [ProviderClass] — no other module touches external libraries directly
- **Error handling:** Per-item try-except in main loop — one item failure never crashes the entire process
-->

## Project-Specific Requirements

<!-- Add any domain-specific requirements here, e.g.:
- Financial data integrity rules
- Security protocols
- Performance requirements
- Compliance standards
-->
```

**After creating CLAUDE.md:**
1. Replace `[Your Project Name]` with actual name
2. Fill in Mirror Testing mappings as you create modules
3. Update Spec-to-Code Mapping table when adding specs
4. Define Architecture Rules based on your design
5. Add Project-Specific Requirements as needed

**Remember**: This is your project's main config. Keep it up-to-date as the project evolves.
